---
title: ã€Swiftã€‘OpenAIã®GPT-3ã‚’Swiftã§çµ±åˆã™ã‚‹æ–¹æ³•
tags:
  - iOS
  - Swift
  - OpenAI
  - gpt-3
private: false
updated_at: '2022-12-24T18:19:46+09:00'
id: b8b9fc91bea22a071dd9
organization_url_name: null
slide: false
---
Swift/Kotlin æ„›å¥½ä¼š Advent Calendar 2022 ã® 18 æ—¥ã®è¨˜äº‹ã§ã™ã€‚
Swift/Kotlin æ„›å¥½ä¼šã®çš†æ§˜ã€ã¨ã‚“ã¨ã‚“ã¼ã¨ç”³ã—ã¾ã™ã€‚Advent Calendar ãã®ã‚‚ã®ãŒåˆå‚åŠ ã§ã™ã€‚ã‚ˆã‚ã—ããŠé¡˜ã„ã„ãŸã—ã¾ã™ğŸ™‡â€â™‚ï¸

# ã¯ã˜ã‚ã«

ã“ã®è¨˜äº‹ã§ã¯ã€ã¾ãšåˆã‚ã« OpenAI ã¨ GPT-3 ã«ã¤ã„ã¦ç°¡å˜ã«è§£èª¬ã—ã€GPT-3 ãƒ¢ãƒ‡ãƒ«ã‚’ iOS ã‚¢ãƒ—ãƒªã«çµ„ã¿è¾¼ã‚€æ–¹æ³•ã‚’ç´¹ä»‹ã—ã¾ã™ã€‚


# OpenAIã¨ã¯
OpenAI ã¨ã¯ã€AI ã®ç ”ç©¶ãƒ»é–‹ç™ºä¼æ¥­ã§ã™ã€‚äººé¡å…¨ä½“ã«åˆ©ç›Šã‚’ã‚‚ãŸã‚‰ã™å½¢ã§å‹å¥½çš„ãª AI ã‚’æ™®åŠãƒ»ç™ºå±•ã•ã›ã‚‹ã“ã¨ã‚’ç›®æ¨™ã«æ²ã’ã¦ã„ã¾ã™ã€‚
2015 å¹´ã«ã‚µãƒ ãƒ»ã‚¢ãƒ«ãƒˆãƒãƒ³ã€ã‚¤ãƒ¼ãƒ­ãƒ³ãƒ»ãƒã‚¹ã‚¯ã‚‰ã«ã‚ˆã£ã¦ã‚µãƒ³ãƒ•ãƒ©ãƒ³ã‚·ã‚¹ã‚³ã§è¨­ç«‹ã•ã‚Œã¾ã—ãŸã€‚

ä¸»ãªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€è‡ªç„¶è¨€èªå‡¦ç†ã¨ç”»åƒç”Ÿæˆãƒ¢ãƒ‡ãƒ«(VAE Clip)ã‚’çµ„ã¿åˆã‚ã›ãŸ**DALL-E**ã€**DALL-E2**ã€
å¼·åŒ–å­¦ç¿’ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®**Gym**,
æ•™å¸«ãªã—å¤‰æ›è¨€èªãƒ¢ãƒ‡ãƒ«ã®**GPT-3**
ãªã©ãŒã‚ã‚Šã¾ã™ã€‚


https://openai.com/


# GPT-3ã¨ã¯
äº‹å‰å­¦ç¿’ã«ã‚ˆã‚‹è‡ªç„¶è¨€èªæŠ€è¡“å‡¦ç†ãƒ¢ãƒ‡ãƒ«ã® 1 ã¤ã§ã™ã€‚
å¤§ããªç‰¹å¾´ã¯ã€ã¾ã‚‹ã§äººãŒæ›¸ã„ãŸã‚ˆã†ã«è‡ªç„¶ãªæ–‡ç« ã‚’ä½œæˆã§ãã‚‹ç‚¹ã§ã™ã€‚

GPT-3 ã¯ã€Web ç­‰ã‹ã‚‰åé›†ã—ãŸ 45TB ã‚‚ã®è†¨å¤§ãªãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã®ã†ã¡ã€ã„ãã¤ã‹ã®å‰å‡¦ç†ã‚’æ–½ã—ãŸ 570GB ã®ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã‚’å­¦ç¿’ã«ç”¨ã„ãŸãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã«å¯¾ã—ã¦ã€ 1,750 å„„å€‹ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŒã¤è‡ªå·±å›å¸°å‹è¨€èªãƒ¢ãƒ‡ãƒ«ï¼ˆã‚ã‚‹å˜èªã®æ¬¡ã«å‡ºã¦ãã‚‹å˜èªã‚’äºˆæ¸¬ã™ã‚‹ãƒ¢ãƒ‡ãƒ«ï¼‰ã‚’å­¦ç¿’ã™ã‚‹ã“ã¨ã§ã€ ä»Šã¾ã§ã‚ã£ãŸã€ŒBERTã€ã‚„ã€ŒGPT-2ã€ã®ãƒ‡ãƒ¼ã‚¿å­¦ç¿’é‡ã‚’é¥ã‹ã«è¶…ãˆãŸã€å·¨å¤§ãªè¨€èªãƒ¢ãƒ‡ãƒ«ã‚’å½¢æˆã—ã¦ã„ã¾ã™ã€‚

åºƒå‘Šã‚„ã‚­ãƒ£ãƒƒãƒã‚³ãƒ”ãƒ¼ã‚„ãƒ‹ãƒ¥ãƒ¼ã‚¹è¨˜äº‹ä½œæˆãªã©ã€ä»Šã¾ã§ã® AI ãƒ¢ãƒ‡ãƒ«ã‚„æ‰‹æ³•ã‚ˆã‚Šã¯ã‚‹ã‹ã«äººé–“ã‚‰ã—ã„æ–‡ç« ã‚’ä½œæˆã§ãã‚‹ã‚ˆã†ã«ãªã£ãŸã¨è¨€ã‚ã‚Œã¦ã„ã¾ã™ã€‚


https://www.data-artist.com/contents/gpt-3.html

# æœ¬é¡Œï¼šä½œæˆæ–¹æ³•
æ–°ã—ã„ Swift ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã€ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã‚’ä½œæˆã—ã¾ã™ã€‚

```swift:OpenAIConnector.swift
import Foundation

public class OpenAIConnector {
    let openAIURL = URL(string: "")
    var openAIKey: String {
        return ""
    }
    
    private func executeRequest(request: URLRequest, withSessionConfig sessionConfig: URLSessionConfiguration?) -> Data? {
        let semaphore = DispatchSemaphore(value: 0)
        let session: URLSession
        if (sessionConfig != nil) {
            session = URLSession(configuration: sessionConfig!)
        } else {
            session = URLSession.shared
        }
        var requestData: Data?
        let task = session.dataTask(with: request as URLRequest, completionHandler:{ (data: Data?, response: URLResponse?, error: Error?) -> Void in
            if error != nil {
                print("error: \(error!.localizedDescription): \(error!.localizedDescription)")
            } else if data != nil {
                requestData = data
            }
            
            print("Semaphore signalled")
            semaphore.signal()
        })
        task.resume()
        
        // semaphoresã§éåŒæœŸå‡¦ç†ã€‚æœ€å¤§10ç§’ã®å¾…ã¡æ™‚é–“
        let timeout = DispatchTime.now() + .seconds(20)
        print("Waiting for semaphore signal")
        let retVal = semaphore.wait(timeout: timeout)
        print("Done waiting, obtained - \(retVal)")
        return requestData
    }
    
    public func processPrompt(
        prompt: String
    ) -> Optional<String> {
        
        var request = URLRequest(url: self.openAIURL!)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.addValue("Bearer \(self.openAIKey)", forHTTPHeaderField: "Authorization")
        let httpBody: [String: Any] = [
            "prompt" : prompt,
            "max_tokens" : 100
        ]
        
        var httpBodyJson: Data
        
        do {
            httpBodyJson = try JSONSerialization.data(withJSONObject: httpBody, options: .prettyPrinted)
        } catch {
            print("Unable to convert to JSON \(error)")
            return nil
        }
        request.httpBody = httpBodyJson
        if let requestData = executeRequest(request: request, withSessionConfig: nil) {
            let jsonStr = String(data: requestData, encoding: String.Encoding(rawValue: String.Encoding.utf8.rawValue))!
            print(jsonStr)

            //MARK: - ä»¥ä¸‹ã€ã‚¨ãƒ©ãƒ¼ãŒå‡ºã¦ã„ã¾ã™ãŒã€è¨˜äº‹ã®å¾ŒåŠã§ä¿®æ­£ã—ã¾ã™ã®ã§ã€å¤‰æ›´ã—ãªã„ã‚ˆã†ã«æ³¨æ„ã—ã¦ãã ã•ã„
            let responseHandler = OpenAIResponseHandler()

            return responseHandler.decodeJson(jsonString: jsonStr)?.choices[0].text
            
        }
        return nil
    }
}
```

ã“ã“ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹ã¨æ€ã„ã¾ã™ãŒã€å¾Œã«è§£æ±ºã™ã‚‹ã®ã§æ°—ã«ã—ãªã„ã§ãã ã•ã„ã€‚

## API Keyã®å—ã‘å–ã‚Š

ã•ã¦ã€æ¬¡ã« OpenAI ã®ã‚µã‚¤ãƒˆã¸è¡Œãã€APIã€€Key ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚

å³ä¸Šã«ã‚ã‚‹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®ã‚¢ã‚¤ã‚³ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã€`View API Keys` ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ã€è‡ªåˆ†ã® key ãŒå…¨ã¦è¡¨ç¤ºã•ã‚ŒãŸãƒšãƒ¼ã‚¸ã«ç§»å‹•ã—ã¾ã™ã€‚

:::note warn
ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’å…¬é–‹ã™ã‚‹å ´åˆã¯ã€APIkey ã‚’éš ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
:::

APIã€€Key ã‚’å…¥æ‰‹ã—ãŸã‚‰ã€‚`class OpenAIConnector` ã® `openAIKey` ã«è²¼ã‚Šä»˜ã‘ã¾ã™ã€‚

```diff_swift:OpenAIConnector.swift
import Foundation

public class OpenAIConnector {
    let openAIURL = URL(string: "")
    var openAIKey: String {
+        return "sk-samplehogehogehogehogehogehogehogehogehoge"
    }
    
    private func executeRequest(request: URLRequest, withSessionConfig sessionConfig: URLSessionConfiguration?) -> Data? {
        let semaphore = DispatchSemaphore(value: 0)
        let session: URLSession
        if (sessionConfig != nil) {
            session = URLSession(configuration: sessionConfig!)
        } else {
            session = URLSession.shared
        }
        var requestData: Data?
        let task = session.dataTask(with: request as URLRequest, completionHandler:{ (data: Data?, response: URLResponse?, error: Error?) -> Void in
            if error != nil {
                print("error: \(error!.localizedDescription): \(error!.localizedDescription)")
            } else if data != nil {
                requestData = data
            }
            
            print("Semaphore signalled")
            semaphore.signal()
        })
        task.resume()
        
        // semaphoresã§éåŒæœŸå‡¦ç†ã€‚æœ€å¤§10ç§’ã®å¾…ã¡æ™‚é–“
        let timeout = DispatchTime.now() + .seconds(20)
        print("Waiting for semaphore signal")
        let retVal = semaphore.wait(timeout: timeout)
        print("Done waiting, obtained - \(retVal)")
        return requestData
    }
    
    public func processPrompt(
        prompt: String
    ) -> Optional<String> {
        
        var request = URLRequest(url: self.openAIURL!)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.addValue("Bearer \(self.openAIKey)", forHTTPHeaderField: "Authorization")
        let httpBody: [String: Any] = [
            "prompt" : prompt,
            "max_tokens" : 100
        ]
        
        var httpBodyJson: Data
        
        do {
            httpBodyJson = try JSONSerialization.data(withJSONObject: httpBody, options: .prettyPrinted)
        } catch {
            print("Unable to convert to JSON \(error)")
            return nil
        }
        request.httpBody = httpBodyJson
        if let requestData = executeRequest(request: request, withSessionConfig: nil) {
            let jsonStr = String(data: requestData, encoding: String.Encoding(rawValue: String.Encoding.utf8.rawValue))!
            print(jsonStr)

            //MARK: - ä»¥ä¸‹ã€ã‚¨ãƒ©ãƒ¼ãŒå‡ºã¦ã„ã¾ã™ãŒã€è¨˜äº‹ã®å¾ŒåŠã§ä¿®æ­£ã—ã¾ã™ã®ã§ã€å¤‰æ›´ã—ãªã„ã‚ˆã†ã«æ³¨æ„ã—ã¦ãã ã•ã„
            let responseHandler = OpenAIResponseHandler()

            return responseHandler.decodeJson(jsonString: jsonStr)?.choices[0].text
            
        }
        
        return nil
    }
}
```

## ãƒ¢ãƒ‡ãƒ«ã®é¸æŠ

æ¬¡ã«ã€ã©ã®ãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ç”¨ã™ã‚‹ã‹é¸æŠã—ã¾ã™ã€‚OpenAI ã«ã¯ 4 ã¤ã®ãƒ¢ãƒ‡ãƒ«ãŒã‚ã‚Šã€ä»¥ä¸‹ã®ä¸­ã‹ã‚‰ URL ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ãã ã•ã„ã€‚

|  ãƒ¢ãƒ‡ãƒ«å  |  èª¬æ˜  |  URL  |
| ---- | ---- | ---- |
|  Davinci  |  ã©ã®ãƒ¢ãƒ‡ãƒ«ã‚ˆã‚Šã‚‚å¼·åŠ›ã§ã€ã©ã®ãƒ¢ãƒ‡ãƒ«ã‚ˆã‚Šã‚‚é«˜ä¾¡ã§ã™  | https://api.openai.com/v1/engines/text-davinci-002/completions |
|  Curie  |  Davinciã‚ˆã‚Šã‚‚é«˜é€Ÿã§å®‰ä¾¡ã§ã™ãŒã€è‹¥å¹²ãƒ‘ãƒ¯ãƒ¼ãŒåŠ£ã‚Šã¾ã™  |ã€€https://api.openai.com/v1/engines/text-davinci-002/completionsã€€ |
|  Babbage  |  æ¨™æº–çš„ãªã‚¿ã‚¹ã‚¯ãŒå¯èƒ½ã§ã€ãã‚Œã»ã©å¼·åŠ›ã§ã¯ãªã„ãŒã€ã‚ˆã‚Šé€Ÿãã€ã‚ˆã‚Šå®‰ã„ã§ã™   |  https://api.openai.com/v1/engines/text-davinci-002/completions  |
|  Ada  |  ä»–ã®ã‚‚ã®ã‚ˆã‚Šã‚‚ãšã£ã¨æ€§èƒ½ã¯åŠ£ã‚Šã¾ã™ãŒã€æœ€ã‚‚é€Ÿãã€æœ€ã‚‚å®‰ä¾¡ã§ã™  |  https://api.openai.com/v1/engines/text-davinci-002/completions  |

ãƒ¢ãƒ‡ãƒ«ã®è©³ç´°ãªèª¬æ˜ã¯ä»¥ä¸‹ã®ãƒªãƒ³ã‚¯ã«ã‚ã‚Šã¾ã™ã€‚

https://beta.openai.com/docs/models/gpt-3

ãƒ¢ãƒ‡ãƒ«ã‚’é¸æŠã—ã€URL ã‚’ã‚³ãƒ”ãƒ¼ã—ãŸã‚‰ã€`class OpenAIConnector` ã«æˆ»ã‚Šã€`openAIURL` ã«è²¼ã‚Šä»˜ã‘ã¾ã™ã€‚ï¼ˆã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã§ã¯ã€Ada ã‚’é¸æŠã—ã¾ã—ãŸã€‚ï¼‰

```diff_swift:OpenAIConnector.swift
import Foundation

public class OpenAIConnector {
+    let openAIURL = URL(string: "https://api.openai.com/v1/engines/text-davinci-002/completions")
    var openAIKey: String {
        return "sk-samplehogehogehogehogehogehogehogehogehoge"
    }
    
    private func executeRequest(request: URLRequest, withSessionConfig sessionConfig: URLSessionConfiguration?) -> Data? {
        let semaphore = DispatchSemaphore(value: 0)
        let session: URLSession
        if (sessionConfig != nil) {
            session = URLSession(configuration: sessionConfig!)
        } else {
            session = URLSession.shared
        }
        var requestData: Data?
        let task = session.dataTask(with: request as URLRequest, completionHandler:{ (data: Data?, response: URLResponse?, error: Error?) -> Void in
            if error != nil {
                print("error: \(error!.localizedDescription): \(error!.localizedDescription)")
            } else if data != nil {
                requestData = data
            }
            
            print("Semaphore signalled")
            semaphore.signal()
        })
        task.resume()
        
        // semaphoresã§éåŒæœŸå‡¦ç†ã€‚æœ€å¤§10ç§’ã®å¾…ã¡æ™‚é–“
        let timeout = DispatchTime.now() + .seconds(20)
        print("Waiting for semaphore signal")
        let retVal = semaphore.wait(timeout: timeout)
        print("Done waiting, obtained - \(retVal)")
        return requestData
    }
    
    public func processPrompt(
        prompt: String
    ) -> Optional<String> {
        
        var request = URLRequest(url: self.openAIURL!)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.addValue("Bearer \(self.openAIKey)", forHTTPHeaderField: "Authorization")
        let httpBody: [String: Any] = [
            "prompt" : prompt,
            "max_tokens" : 100
        ]
        
        var httpBodyJson: Data
        
        do {
            httpBodyJson = try JSONSerialization.data(withJSONObject: httpBody, options: .prettyPrinted)
        } catch {
            print("Unable to convert to JSON \(error)")
            return nil
        }
        request.httpBody = httpBodyJson
        if let requestData = executeRequest(request: request, withSessionConfig: nil) {
            let jsonStr = String(data: requestData, encoding: String.Encoding(rawValue: String.Encoding.utf8.rawValue))!
            print(jsonStr)

            //MARK: - ä»¥ä¸‹ã€ã‚¨ãƒ©ãƒ¼ãŒå‡ºã¦ã„ã¾ã™ãŒã€è¨˜äº‹ã®å¾ŒåŠã§ä¿®æ­£ã—ã¾ã™ã®ã§ã€å¤‰æ›´ã—ãªã„ã‚ˆã†ã«æ³¨æ„ã—ã¦ãã ã•ã„
            let responseHandler = OpenAIResponseHandler()

            return responseHandler.decodeJson(jsonString: jsonStr)?.choices[0].text
            
        }
        
        return nil
    }
}
```

æœ€å¾Œã«ã€`OpenAIResponseHandler.swift` ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¦ã€ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã‚’ä½œæˆã—ã¾ã™ã€‚

```swift:OpenAIResponseHandler.swift
struct OpenAIResponseHandler {
    func decodeJson(jsonString: String) -> OpenAIResponse? {
        let json = jsonString.data(using: .utf8)!
        
        let decoder = JSONDecoder()
        do {
            let product = try decoder.decode(OpenAIResponse.self, from: json)
            return product
            
        } catch {
            print("Error decoding OpenAI API Response")
        }
        
        return nil
    }
}

struct OpenAIResponse: Codable {
    var id: String
    var object: String
    var created: Int
    var model: String
    var choices: [Choice]
}

struct Choice: Codable {
    var text: String
    var index: Int
    var logprobs: String?
    var finish_reason: String
}
```

ä»¥ä¸Šã§æº–å‚™ãŒå®Œäº†ã—ã¾ã—ãŸã€‚å¾Œã¯è‡ªåˆ†ã®å¥½ããªå ´æ‰€ã§ `OpenAIConnector().processPrompt(prompt: )` ã¨ã„ã†é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã ã‘ã§ã€å®Œäº†ã§ã™ã€‚

# æœ€å¾Œã«
OpenAI ã«ã¯ä»–ã«ã‚‚è‡ªç„¶è¨€èªã‹ã‚‰ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã¸å¤‰æ›ã™ã‚‹ Codex ã‚·ãƒªãƒ¼ã‚ºã¨ã„ã†ã‚µãƒ¼ãƒ“ã‚¹ã‚‚ã‚ã‚Šã¾ã™ã€‚
æ°—ã«ãªã‚‹ã‹ãŸã¯ãœã²å‚ç…§ã—ã¦ã¿ã¦ãã ã•ã„

https://beta.openai.com/docs/models/codex
